#!/usr/bin/env python3
"""
METADATA SCRUBBER BOT v4.0 - COMPLETE IMAGE & VIDEO SUPPORT
Removes ALL metadata and adds custom metadata to images AND videos
Author: Professor
Contact: +880 1708005924 (WhatsApp)
"""

import os
import sys
import json
import shutil
import subprocess
import argparse
from datetime import datetime, timedelta
from pathlib import Path
from PIL import Image
from PIL.ExifTags import TAGS, GPSTAGS
import piexif
import random
import warnings
import ffmpeg
import mutagen
from mutagen.mp4 import MP4, MP4Cover
from mutagen.id3 import ID3, TIT2, TPE1, TALB, TDRC, TCON, COMM, TXXX, APIC
from mutagen.easyid3 import EasyID3
import hashlib
import time

warnings.filterwarnings('ignore')

# ============================================================================
# CUSTOM BANNER & CREDITS
# ============================================================================

CUSTOM_BANNER = r"""
â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— 
â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—
â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘
â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘
â•šâ•â•     â•šâ•â•â•šâ•â•â•â•â•â•â•   â•šâ•â•   â•šâ•â•  â•šâ•â•    â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â•  â•šâ•â•
"""

CREDITS = """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                              CREDITS                                 â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Developer: Professor                                               â•‘
â•‘  Contact: +880 1708005924 (WhatsApp)                               â•‘
â•‘  Version: 4.0 - Complete Media Metadata Scrubber                   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

# ============================================================================
# CONFIGURATION
# ============================================================================

class Config:
    """Global configuration"""
    APP_NAME = "META DATA SCRUBBER BOT v4.0"
    VERSION = "4.0"
    DEFAULT_INPUT_DIR = "input_media"
    DEFAULT_OUTPUT_DIR = "scrubbed_media"
    CONFIG_FILE = ".metadata_scrubber_config.json"
    FFMPEG_PATH = "ffmpeg"
    
    # Supported formats
    SUPPORTED_IMAGE_FORMATS = ['.jpg', '.jpeg', '.png', '.webp', '.tiff', '.bmp', '.heic', '.heif']
    SUPPORTED_VIDEO_FORMATS = ['.mp4', '.mov', '.avi', '.mkv', '.webm', '.flv', '.wmv', '.m4v', '.mpg', '.mpeg']
    SUPPORTED_AUDIO_FORMATS = ['.mp3', '.wav', '.flac', '.aac', '.m4a', '.ogg']
    
    ALL_SUPPORTED_FORMATS = SUPPORTED_IMAGE_FORMATS + SUPPORTED_VIDEO_FORMATS + SUPPORTED_AUDIO_FORMATS
    
    # AI Metadata markers
    AI_METADATA_MARKERS = [
        'AI-Generated', 'Stable Diffusion', 'DALL-E', 'Midjourney',
        'DreamStudio', 'NovelAI', 'Craiyon', 'Adobe Firefly',
        'Generated by AI', 'AI Created', 'Artificial Intelligence',
        'SDXL', 'SD 1.5', 'SD 2.1', 'Clipdrop', 'Playground AI',
        'Negative prompt', 'Steps:', 'Sampler:', 'CFG scale:',
        'Seed:', 'Size:', 'Model:', 'Model hash:', 'Denoising strength:',
        'Hires upscale:', 'Hires steps:', 'Version:',
        'Synthesia', 'RunwayML', 'Pika Labs', 'HeyGen', 'DeepBrain'
    ]

# ============================================================================
# INTERACTIVE WIZARD
# ============================================================================

class MetadataWizard:
    """Interactive terminal wizard for metadata input"""
    
    @staticmethod
    def print_header(title):
        """Print formatted header"""
        print("\n" + "â•" * 60)
        print(f"  {title}")
        print("â•" * 60)
    
    @staticmethod
    def print_step(step_num, description):
        """Print step information"""
        print(f"\n[Step {step_num}] {description}")
        print("-" * 40)
    
    @staticmethod
    def get_input(prompt, default="", required=True):
        """Get user input with validation"""
        while True:
            if default:
                user_input = input(f"{prompt} [{default}]: ").strip()
                if not user_input:
                    return default
            else:
                user_input = input(f"{prompt}: ").strip()
            
            if not user_input and required:
                print("âš ï¸  This field is required. Please enter a value.")
                continue
            
            return user_input
    
    @staticmethod
    def get_choice(prompt, options, default=None):
        """Get choice from multiple options"""
        print(f"\n{prompt}:")
        for i, option in enumerate(options, 1):
            print(f"  {i}. {option}")
        
        while True:
            if default:
                choice = input(f"\nEnter choice (1-{len(options)}) [{default}]: ").strip()
                if not choice:
                    choice = default
            else:
                choice = input(f"\nEnter choice (1-{len(options)}): ").strip()
            
            if choice.isdigit() and 1 <= int(choice) <= len(options):
                return options[int(choice) - 1]
            print(f"âš ï¸  Please enter a number between 1 and {len(options)}")
    
    @staticmethod
    def get_metadata_interactive(media_type="image"):
        """Interactive metadata collection wizard"""
        MetadataWizard.print_header(f"METADATA CONFIGURATION FOR {media_type.upper()}S")
        
        print("I'll guide you through setting up custom metadata for your media.")
        print("Press Enter to use default values in brackets [].\n")
        
        metadata = {}
        
        # Step 1: Device/Software Selection
        MetadataWizard.print_step(1, f"SELECT {media_type.upper()} SOURCE")
        
        if media_type == "image":
            devices = [
                "iPhone 12",
                "iPhone 13 Pro", 
                "iPhone 14 Pro Max",
                "Samsung Galaxy S23",
                "Google Pixel 7",
                "Canon EOS R6",
                "Sony A7 IV",
                "Custom Camera"
            ]
        elif media_type == "video":
            devices = [
                "iPhone 12",
                "iPhone 13 Pro",
                "Samsung Galaxy S23",
                "GoPro Hero 11",
                "Sony A7S III",
                "DJI Mavic 3",
                "Screen Recording",
                "Custom Source"
            ]
        else:  # audio
            devices = [
                "iPhone Voice Memo",
                "Zoom H5 Recorder",
                "Audio Technica Mic",
                "Screen Recording",
                "Custom Source"
            ]
        
        device = MetadataWizard.get_choice(f"Select {media_type} source", devices, "1")
        if "Custom" in device:
            device = MetadataWizard.get_input(f"Enter custom {media_type} source", f"Custom {media_type.title()} Source")
        metadata['Device'] = device
        
        # Step 2: Date and Time
        MetadataWizard.print_step(2, "SET DATE AND TIME")
        
        # Date
        today = datetime.now()
        yesterday = today - timedelta(days=1)
        date_options = [
            f"Today ({today.strftime('%m.%d.%Y')})",
            f"Yesterday ({yesterday.strftime('%m.%d.%Y')})",
            "Custom Date"
        ]
        
        date_choice = MetadataWizard.get_choice("Select date", date_options, "1")
        if "Today" in date_choice:
            metadata['Date'] = today.strftime('%m.%d.%Y')
        elif "Yesterday" in date_choice:
            metadata['Date'] = yesterday.strftime('%m.%d.%Y')
        else:
            while True:
                custom_date = MetadataWizard.get_input("Enter date (MM.DD.YYYY)", today.strftime('%m.%d.%Y'))
                try:
                    datetime.strptime(custom_date, '%m.%d.%Y')
                    metadata['Date'] = custom_date
                    break
                except ValueError:
                    print("âš ï¸  Invalid date format. Use MM.DD.YYYY")
        
        # Time
        time_options = [
            "Random daytime (08:00-18:00)",
            "Random nighttime (19:00-23:00)",
            "Current time",
            "Custom time"
        ]
        
        time_choice = MetadataWizard.get_choice("Select time", time_options, "1")
        if "Random daytime" in time_choice:
            hour = random.randint(8, 17)
            minute = random.randint(0, 59)
            second = random.randint(0, 59)
            metadata['Time'] = f"{hour:02d}:{minute:02d}:{second:02d}"
        elif "Random nighttime" in time_choice:
            hour = random.randint(19, 23)
            minute = random.randint(0, 59)
            second = random.randint(0, 59)
            metadata['Time'] = f"{hour:02d}:{minute:02d}:{second:02d}"
        elif "Current time" in time_choice:
            metadata['Time'] = today.strftime('%H:%M:%S')
        else:
            while True:
                custom_time = MetadataWizard.get_input("Enter time (HH:MM:SS)", today.strftime('%H:%M:%S'))
                try:
                    datetime.strptime(custom_time, '%H:%M:%S')
                    metadata['Time'] = custom_time
                    break
                except ValueError:
                    print("âš ï¸  Invalid time format. Use HH:MM:SS")
        
        # Step 3: Location (for images and videos)
        if media_type in ["image", "video"]:
            MetadataWizard.print_step(3, "SET LOCATION")
            
            locations = [
                "New York, USA",
                "Los Angeles, USA",
                "London, UK",
                "Tokyo, Japan",
                "Paris, France",
                "Sydney, Australia",
                "Dubai, UAE",
                "Custom Location"
            ]
            
            location = MetadataWizard.get_choice("Select location", locations, "1")
            if location == "Custom Location":
                location = MetadataWizard.get_input("Enter custom location", "Unknown Location")
            metadata['Location'] = location
        else:
            metadata['Location'] = "Not applicable"
        
        # Step 4: Additional Settings
        MetadataWizard.print_step(4, "ADDITIONAL SETTINGS")
        
        if media_type == "image":
            add_gps = MetadataWizard.get_input("Add GPS coordinates? (yes/no)", "yes").lower()
            metadata['AddGPS'] = add_gps in ['yes', 'y', '1']
            
            add_camera_settings = MetadataWizard.get_input("Add realistic camera settings? (yes/no)", "yes").lower()
            metadata['AddCameraSettings'] = add_camera_settings in ['yes', 'y', '1']
        
        elif media_type == "video":
            add_creator = MetadataWizard.get_input("Add creator name? (yes/no)", "yes").lower()
            if add_creator in ['yes', 'y', '1']:
                metadata['Creator'] = MetadataWizard.get_input("Enter creator name", "User")
            
            add_description = MetadataWizard.get_input("Add video description? (yes/no)", "no").lower()
            if add_description in ['yes', 'y', '1']:
                metadata['Description'] = MetadataWizard.get_input("Enter video description", "Personal Video")
        
        elif media_type == "audio":
            add_artist = MetadataWizard.get_input("Add artist name? (yes/no)", "yes").lower()
            if add_artist in ['yes', 'y', '1']:
                metadata['Artist'] = MetadataWizard.get_input("Enter artist name", "User")
            
            add_album = MetadataWizard.get_input("Add album name? (yes/no)", "no").lower()
            if add_album in ['yes', 'y', '1']:
                metadata['Album'] = MetadataWizard.get_input("Enter album name", "Recordings")
        
        # Step 5: Review and Confirm
        MetadataWizard.print_step(5, "REVIEW AND CONFIRM")
        
        print("\nğŸ“‹ METADATA SUMMARY:")
        print("-" * 40)
        for key, value in metadata.items():
            if key not in ['AddGPS', 'AddCameraSettings']:
                print(f"  {key}: {value}")
        
        if media_type == "image":
            print(f"\n  Add GPS: {'Yes' if metadata.get('AddGPS', True) else 'No'}")
            print(f"  Camera Settings: {'Yes' if metadata.get('AddCameraSettings', True) else 'No'}")
        
        print("-" * 40)
        
        confirm = MetadataWizard.get_input("\nProceed with these settings? (yes/no)", "yes").lower()
        if confirm not in ['yes', 'y', '1']:
            print("Configuration cancelled.")
            return None
        
        return metadata

# ============================================================================
# FOLDER MANAGER
# ============================================================================

class FolderManager:
    """Manages input/output folder creation and setup"""
    
    @staticmethod
    def setup_folders():
        """Create default folders if they don't exist"""
        print("\n" + "â•" * 60)
        print("  FOLDER SETUP")
        print("â•" * 60)
        
        # Create input directory
        if not os.path.exists(Config.DEFAULT_INPUT_DIR):
            os.makedirs(Config.DEFAULT_INPUT_DIR)
            print(f"âœ… Created input folder: {Config.DEFAULT_INPUT_DIR}/")
            print(f"   Place your images/videos/audio files here before processing")
        else:
            print(f"ğŸ“ Input folder already exists: {Config.DEFAULT_INPUT_DIR}/")
        
        # Create output directory
        if not os.path.exists(Config.DEFAULT_OUTPUT_DIR):
            os.makedirs(Config.DEFAULT_OUTPUT_DIR)
            print(f"âœ… Created output folder: {Config.DEFAULT_OUTPUT_DIR}/")
            print(f"   Processed media will be saved here")
        else:
            print(f"ğŸ“ Output folder already exists: {Config.DEFAULT_OUTPUT_DIR}/")
        
        # Check for media files
        media_count = 0
        media_by_type = {"images": 0, "videos": 0, "audio": 0}
        
        for ext in Config.SUPPORTED_IMAGE_FORMATS:
            media_count += len(list(Path(Config.DEFAULT_INPUT_DIR).glob(f"*{ext}")))
            media_count += len(list(Path(Config.DEFAULT_INPUT_DIR).glob(f"*{ext.upper()}")))
            media_by_type["images"] += len(list(Path(Config.DEFAULT_INPUT_DIR).glob(f"*{ext}")))
        
        for ext in Config.SUPPORTED_VIDEO_FORMATS:
            media_count += len(list(Path(Config.DEFAULT_INPUT_DIR).glob(f"*{ext}")))
            media_count += len(list(Path(Config.DEFAULT_INPUT_DIR).glob(f"*{ext.upper()}")))
            media_by_type["videos"] += len(list(Path(Config.DEFAULT_INPUT_DIR).glob(f"*{ext}")))
        
        for ext in Config.SUPPORTED_AUDIO_FORMATS:
            media_count += len(list(Path(Config.DEFAULT_INPUT_DIR).glob(f"*{ext}")))
            media_count += len(list(Path(Config.DEFAULT_INPUT_DIR).glob(f"*{ext.upper()}")))
            media_by_type["audio"] += len(list(Path(Config.DEFAULT_INPUT_DIR).glob(f"*{ext}")))
        
        if media_count > 0:
            print(f"\nğŸ“Š Found {media_count} media file(s):")
            print(f"   ğŸ“¸ Images: {media_by_type['images']}")
            print(f"   ğŸ¥ Videos: {media_by_type['videos']}")
            print(f"   ğŸµ Audio: {media_by_type['audio']}")
        else:
            print(f"\nâš ï¸  No media files found in input folder")
            print(f"   Please add images/videos/audio to {Config.DEFAULT_INPUT_DIR}/ before processing")
        
        print("â•" * 60)
        return Config.DEFAULT_INPUT_DIR, Config.DEFAULT_OUTPUT_DIR
    
    @staticmethod
    def show_folder_contents():
        """Show contents of input and output folders"""
        print("\nğŸ“ FOLDER CONTENTS:")
        print("-" * 40)
        
        # Input folder
        print(f"Input ({Config.DEFAULT_INPUT_DIR}/):")
        input_files = []
        for ext in Config.ALL_SUPPORTED_FORMATS:
            for file in Path(Config.DEFAULT_INPUT_DIR).glob(f"*{ext}"):
                input_files.append(file)
            for file in Path(Config.DEFAULT_INPUT_DIR).glob(f"*{ext.upper()}"):
                input_files.append(file)
        
        if input_files:
            # Group by type
            images = [f for f in input_files if f.suffix.lower() in Config.SUPPORTED_IMAGE_FORMATS]
            videos = [f for f in input_files if f.suffix.lower() in Config.SUPPORTED_VIDEO_FORMATS]
            audio = [f for f in input_files if f.suffix.lower() in Config.SUPPORTED_AUDIO_FORMATS]
            
            if images:
                print(f"  ğŸ“¸ Images ({len(images)}):")
                for file in sorted(images)[:3]:
                    size = file.stat().st_size // 1024
                    print(f"    - {file.name} ({size} KB)")
                if len(images) > 3:
                    print(f"    ... and {len(images) - 3} more")
            
            if videos:
                print(f"  ğŸ¥ Videos ({len(videos)}):")
                for file in sorted(videos)[:3]:
                    size = file.stat().st_size // (1024 * 1024)
                    print(f"    - {file.name} ({size} MB)")
                if len(videos) > 3:
                    print(f"    ... and {len(videos) - 3} more")
            
            if audio:
                print(f"  ğŸµ Audio ({len(audio)}):")
                for file in sorted(audio)[:3]:
                    size = file.stat().st_size // 1024
                    print(f"    - {file.name} ({size} KB)")
                if len(audio) > 3:
                    print(f"    ... and {len(audio) - 3} more")
        else:
            print("  (empty)")
        
        # Output folder
        print(f"\nOutput ({Config.DEFAULT_OUTPUT_DIR}/):")
        output_files = list(Path(Config.DEFAULT_OUTPUT_DIR).glob("*"))
        if output_files:
            for file in sorted(output_files)[:5]:
                size = file.stat().st_size // 1024
                icon = "ğŸ“¸" if file.suffix.lower() in Config.SUPPORTED_IMAGE_FORMATS else "ğŸ¥" if file.suffix.lower() in Config.SUPPORTED_VIDEO_FORMATS else "ğŸµ"
                print(f"  {icon} {file.name} ({size} KB)")
        else:
            print("  (empty)")
        
        print("-" * 40)

# ============================================================================
# METADATA ENGINE - IMAGES
# ============================================================================

class ImageMetadataEngine:
    """Image metadata processing engine"""
    
    # Camera profiles database
    CAMERA_PROFILES = {
        'iPhone 12': {
            'Make': 'Apple',
            'Model': 'iPhone 12',
            'Software': 'iOS 16.6',
            'FocalLength': (42, 10),  # 4.2mm
            'FNumber': (16, 10),  # f/1.6
            'ExposureTime': (1, 120),  # 1/120s
            'ISOSpeedRatings': 32
        },
        'iPhone 13 Pro': {
            'Make': 'Apple',
            'Model': 'iPhone 13 Pro',
            'Software': 'iOS 17.2',
            'FocalLength': (60, 10),  # 6.0mm
            'FNumber': (15, 10),  # f/1.5
            'ExposureTime': (1, 100),  # 1/100s
            'ISOSpeedRatings': 64
        },
        'Samsung Galaxy S23': {
            'Make': 'Samsung',
            'Model': 'SM-S911B',
            'Software': 'Android 14',
            'FocalLength': (67, 10),  # 6.7mm
            'FNumber': (17, 10),  # f/1.7
            'ExposureTime': (1, 125),  # 1/125s
            'ISOSpeedRatings': 50
        },
        'Canon EOS R6': {
            'Make': 'Canon',
            'Model': 'EOS R6 Mark II',
            'Software': 'Digital Photo Professional 4.0',
            'FocalLength': (500, 10),  # 50.0mm
            'FNumber': (18, 10),  # f/1.8
            'ExposureTime': (1, 250),  # 1/250s
            'ISOSpeedRatings': 100
        }
    }
    
    # GPS coordinates database
    GPS_COORDINATES = {
        "New York, USA": (40.7128, -74.0060),
        "Los Angeles, USA": (34.0522, -118.2437),
        "London, UK": (51.5074, -0.1278),
        "Tokyo, Japan": (35.6762, 139.6503),
        "Paris, France": (48.8566, 2.3522),
        "Sydney, Australia": (-33.8688, 151.2093),
        "Dubai, UAE": (25.2048, 55.2708),
        "Unknown Location": (0.0, 0.0)
    }
    
    def __init__(self, verbose=False):
        self.verbose = verbose
    
    def log(self, message, level="info"):
        """Log messages"""
        if self.verbose or level in ["success", "error", "warning"]:
            prefixes = {
                "info": "[*]",
                "success": "[âœ…]",
                "warning": "[âš ï¸]",
                "error": "[âŒ]"
            }
            print(f"{prefixes.get(level, '[ ]')} {message}")
    
    def detect_ai_metadata(self, exif_dict):
        """Detect AI-generated metadata in images"""
        ai_indicators = []
        
        if not exif_dict:
            return ai_indicators
        
        # Check various EXIF fields for AI markers
        for ifd in ["0th", "Exif"]:
            if ifd in exif_dict:
                for tag, value in exif_dict[ifd].items():
                    if isinstance(value, bytes):
                        try:
                            value_str = value.decode('utf-8', errors='ignore').lower()
                        except:
                            value_str = str(value).lower()
                    else:
                        value_str = str(value).lower()
                    
                    for marker in Config.AI_METADATA_MARKERS:
                        if marker.lower() in value_str:
                            tag_name = TAGS.get(tag, f"Tag {tag}")
                            ai_indicators.append(f"{tag_name}: {value_str[:50]}...")
        
        return ai_indicators
    
    def strip_all_metadata(self, image_path):
        """Completely strip all metadata from image"""
        try:
            # Method 1: Create new image without metadata
            img = Image.open(image_path)
            
            # Convert to RGB if necessary (removes alpha channel metadata)
            if img.mode in ('RGBA', 'LA', 'P'):
                background = Image.new('RGB', img.size, (255, 255, 255))
                if img.mode == 'P':
                    img = img.convert('RGBA')
                background.paste(img, mask=img.split()[-1] if img.mode == 'RGBA' else None)
                img = background
            elif img.mode != 'RGB':
                img = img.convert('RGB')
            
            # Get image data and create clean image
            data = list(img.getdata())
            clean_img = Image.new(img.mode, img.size)
            clean_img.putdata(data)
            
            return clean_img
            
        except Exception as e:
            self.log(f"Failed to strip metadata: {e}", "error")
            return None
    
    def create_exif_metadata(self, metadata_dict):
        """Create EXIF metadata from metadata dictionary"""
        exif_dict = {
            "0th": {},
            "Exif": {},
            "GPS": {},
            "1st": {},
            "thumbnail": None
        }
        
        # Get device profile
        device = metadata_dict.get('Device', 'iPhone 12')
        if device in self.CAMERA_PROFILES:
            profile = self.CAMERA_PROFILES[device]
        else:
            profile = self.CAMERA_PROFILES['iPhone 12']
        
        # Basic camera info
        exif_dict["0th"][piexif.ImageIFD.Make] = profile['Make'].encode('utf-8')
        exif_dict["0th"][piexif.ImageIFD.Model] = profile['Model'].encode('utf-8')
        exif_dict["0th"][piexif.ImageIFD.Software] = profile['Software'].encode('utf-8')
        exif_dict["0th"][piexif.ImageIFD.ImageDescription] = b"Personal Photo"
        exif_dict["0th"][piexif.ImageIFD.Artist] = b"User"
        
        # Date and time
        date_str = metadata_dict.get('Date', datetime.now().strftime('%m.%d.%Y'))
        time_str = metadata_dict.get('Time', datetime.now().strftime('%H:%M:%S'))
        
        # Convert date to EXIF format
        try:
            date_obj = datetime.strptime(date_str, '%m.%d.%Y')
            exif_date = date_obj.strftime('%Y:%m:%d')
        except:
            exif_date = datetime.now().strftime('%Y:%m:%d')
        
        datetime_str = f"{exif_date} {time_str}"
        exif_dict["Exif"][piexif.ExifIFD.DateTimeOriginal] = datetime_str.encode('utf-8')
        exif_dict["Exif"][piexif.ExifIFD.DateTimeDigitized] = datetime_str.encode('utf-8')
        exif_dict["0th"][piexif.ImageIFD.DateTime] = datetime_str.encode('utf-8')
        
        # Camera settings if requested
        if metadata_dict.get('AddCameraSettings', True):
            exif_dict["Exif"][piexif.ExifIFD.FocalLength] = profile['FocalLength']
            exif_dict["Exif"][piexif.ExifIFD.FNumber] = profile['FNumber']
            exif_dict["Exif"][piexif.ExifIFD.ExposureTime] = profile['ExposureTime']
            exif_dict["Exif"][piexif.ExifIFD.ISOSpeedRatings] = profile['ISOSpeedRatings']
            
            # Add some random but realistic values
            exif_dict["Exif"][piexif.ExifIFD.ShutterSpeedValue] = (680, 100)  # EV
            exif_dict["Exif"][piexif.ExifIFD.ApertureValue] = (150, 100)  # APEX
            exif_dict["Exif"][piexif.ExifIFD.ExposureBiasValue] = (0, 1)  # EV
            exif_dict["Exif"][piexif.ExifIFD.MeteringMode] = 5  # Pattern
            exif_dict["Exif"][piexif.ExifIFD.Flash] = 16  # No flash
            exif_dict["Exif"][piexif.ExifIFD.ColorSpace] = 1  # sRGB
        
        # GPS data if requested
        if metadata_dict.get('AddGPS', True):
            location = metadata_dict.get('Location', 'Unknown Location')
            if location in self.GPS_COORDINATES:
                lat, lon = self.GPS_COORDINATES[location]
                
                exif_dict["GPS"][piexif.GPSIFD.GPSLatitudeRef] = 'N' if lat >= 0 else 'S'
                exif_dict["GPS"][piexif.GPSIFD.GPSLatitude] = self.degrees_to_exif(abs(lat))
                
                exif_dict["GPS"][piexif.GPSIFD.GPSLongitudeRef] = 'E' if lon >= 0 else 'W'
                exif_dict["GPS"][piexif.GPSIFD.GPSLongitude] = self.degrees_to_exif(abs(lon))
                
                exif_dict["GPS"][piexif.GPSIFD.GPSAltitudeRef] = 0  # Above sea level
                exif_dict["GPS"][piexif.GPSIFD.GPSAltitude] = (random.randint(0, 100), 1)
                exif_dict["GPS"][piexif.GPSIFD.GPSTimeStamp] = self.time_to_exif(time_str)
        
        # User comment with all metadata
        user_data = {
            'Device': metadata_dict.get('Device', 'Unknown'),
            'Location': metadata_dict.get('Location', 'Unknown'),
            'Date': metadata_dict.get('Date', ''),
            'Time': metadata_dict.get('Time', ''),
            'ProcessedBy': Config.APP_NAME
        }
        exif_dict["Exif"][piexif.ExifIFD.UserComment] = json.dumps(user_data).encode('utf-8')
        
        return exif_dict
    
    def degrees_to_exif(self, degrees):
        """Convert decimal degrees to EXIF format"""
        deg = int(degrees)
        minutes = (degrees - deg) * 60
        min_int = int(minutes)
        sec = (minutes - min_int) * 60
        sec_int = int(sec * 100)
        
        return [(deg, 1), (min_int, 1), (sec_int, 100)]
    
    def time_to_exif(self, time_str):
        """Convert time string to EXIF format"""
        try:
            hours, minutes, seconds = map(int, time_str.split(':'))
            return [(hours, 1), (minutes, 1), (seconds, 1)]
        except:
            now = datetime.now()
            return [(now.hour, 1), (now.minute, 1), (now.second, 1)]
    
    def process_image(self, input_path, output_path, metadata_dict):
        """Process a single image"""
        try:
            self.log(f"Processing image: {os.path.basename(input_path)}")
            
            # Strip all existing metadata
            clean_img = self.strip_all_metadata(input_path)
            if not clean_img:
                return False
            
            # Detect AI metadata in original
            try:
                img = Image.open(input_path)
                exif_data = img.info.get('exif')
                if exif_data:
                    exif_dict = piexif.load(exif_data)
                    ai_detected = self.detect_ai_metadata(exif_dict)
                    if ai_detected:
                        self.log(f"Found {len(ai_detected)} AI metadata indicators", "warning")
            except:
                pass
            
            # Create new metadata
            new_exif = self.create_exif_metadata(metadata_dict)
            exif_bytes = piexif.dump(new_exif)
            
            # Save with new metadata
            clean_img.save(output_path, exif=exif_bytes, quality=95)
            
            self.log(f"Saved: {os.path.basename(output_path)}", "success")
            return True
            
        except Exception as e:
            self.log(f"Error processing image: {e}", "error")
            return False

# ============================================================================
# METADATA ENGINE - VIDEOS
# ============================================================================

class VideoMetadataEngine:
    """Video metadata processing engine"""
    
    def __init__(self, verbose=False):
        self.verbose = verbose
        self.ffmpeg_path = Config.FFMPEG_PATH
    
    def log(self, message, level="info"):
        """Log messages"""
        if self.verbose or level in ["success", "error", "warning"]:
            prefixes = {
                "info": "[*]",
                "success": "[âœ…]",
                "warning": "[âš ï¸]",
                "error": "[âŒ]"
            }
            print(f"{prefixes.get(level, '[ ]')} {message}")
    
    def check_ffmpeg(self):
        """Check if ffmpeg is available"""
        try:
            result = subprocess.run([self.ffmpeg_path, "-version"], 
                                  capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                return True
        except:
            pass
        
        self.log("FFmpeg not found. Video processing requires FFmpeg.", "error")
        self.log("Install with: sudo apt install ffmpeg  or  brew install ffmpeg", "warning")
        return False
    
    def strip_video_metadata(self, input_path, output_path):
        """Strip all metadata from video using ffmpeg"""
        try:
            self.log(f"Stripping metadata from video...")
            
            # FFmpeg command to copy video/audio without metadata
            cmd = [
                self.ffmpeg_path,
                '-i', input_path,
                '-map_metadata', '-1',  # Remove all metadata
                '-map', '0',  # Copy all streams
                '-codec', 'copy',  # Copy without re-encoding
                '-movflags', '+faststart',  # Optimize for web
                output_path
            ]
            
            # Run ffmpeg
            process = subprocess.run(cmd, capture_output=True, text=True)
            
            if process.returncode == 0:
                self.log(f"Video metadata stripped successfully", "success")
                return True
            else:
                self.log(f"FFmpeg error: {process.stderr[:200]}", "error")
                return False
                
        except Exception as e:
            self.log(f"Error stripping video metadata: {e}", "error")
            return False
    
    def add_video_metadata(self, video_path, metadata_dict):
        """Add custom metadata to video file"""
        try:
            self.log(f"Adding metadata to video...")
            
            video_ext = Path(video_path).suffix.lower()
            
            if video_ext in ['.mp4', '.m4v', '.mov']:
                return self.add_mp4_metadata(video_path, metadata_dict)
            elif video_ext in ['.avi', '.mkv', '.webm', '.flv', '.wmv']:
                return self.add_generic_metadata(video_path, metadata_dict)
            else:
                self.log(f"Unsupported video format: {video_ext}", "warning")
                return False
                
        except Exception as e:
            self.log(f"Error adding video metadata: {e}", "error")
            return False
    
    def add_mp4_metadata(self, video_path, metadata_dict):
        """Add metadata to MP4/MOV files using mutagen"""
        try:
            # Load or create MP4 file
            video = MP4(video_path)
            
            # Clear all existing metadata
            video.clear()
            
            # Add basic metadata
            device = metadata_dict.get('Device', 'iPhone 12')
            date_str = metadata_dict.get('Date', datetime.now().strftime('%m.%d.%Y'))
            time_str = metadata_dict.get('Time', datetime.now().strftime('%H:%M:%S'))
            
            # Convert date format
            try:
                date_obj = datetime.strptime(date_str, '%m.%d.%Y')
                iso_date = date_obj.strftime('%Y-%m-%d')
            except:
                iso_date = datetime.now().strftime('%Y-%m-%d')
            
            # Set metadata tags
            video["\xa9nam"] = ["Personal Video"]  # Title
            video["\xa9ART"] = [device]  # Artist (device)
            video["\xa9alb"] = ["Recordings"]  # Album
            video["\xa9day"] = [iso_date]  # Year
            video["\xa9cmt"] = [f"Recorded on {device} at {time_str}"]  # Comment
            
            # Add creation date
            video["\xa9day"] = [iso_date]
            video["\xa9TIM"] = [time_str]
            
            # Add location if available
            location = metadata_dict.get('Location', '')
            if location:
                video["\xa9xyz"] = [f"Location: {location}"]
            
            # Add creator if specified
            creator = metadata_dict.get('Creator', '')
            if creator:
                video["\xa9ART"] = [creator]
                video["\xa9wrk"] = [device]
            
            # Add description if specified
            description = metadata_dict.get('Description', '')
            if description:
                video["desc"] = [description]
            
            # Add custom metadata tag
            custom_data = json.dumps({
                'ProcessedBy': Config.APP_NAME,
                'OriginalDevice': device,
                'Date': date_str,
                'Time': time_str,
                'Location': metadata_dict.get('Location', 'Unknown')
            })
            video["----:com.apple.iTunes:CustomMetadata"] = custom_data.encode('utf-8')
            
            # Save metadata
            video.save()
            
            self.log(f"MP4 metadata added successfully", "success")
            return True
            
        except Exception as e:
            self.log(f"Error adding MP4 metadata: {e}", "error")
            return False
    
    def add_generic_metadata(self, video_path, metadata_dict):
        """Add metadata to generic video formats using ffmpeg"""
        try:
            # Create temporary file
            temp_path = f"{video_path}.temp"
            
            # Build metadata string
            device = metadata_dict.get('Device', 'iPhone 12')
            date_str = metadata_dict.get('Date', datetime.now().strftime('%m.%d.%Y'))
            time_str = metadata_dict.get('Time', datetime.now().strftime('%H:%M:%S'))
            
            # FFmpeg command to add metadata
            cmd = [
                self.ffmpeg_path,
                '-i', video_path,
                '-metadata', f'title=Personal Video',
                '-metadata', f'artist={device}',
                '-metadata', f'date={date_str}',
                '-metadata', f'comment=Recorded on {device} at {time_str}',
                '-metadata', f'description=Processed by {Config.APP_NAME}',
                '-codec', 'copy',  # Copy without re-encoding
                temp_path
            ]
            
            # Add location if available
            location = metadata_dict.get('Location', '')
            if location:
                cmd.insert(-1, '-metadata')
                cmd.insert(-1, f'location={location}')
            
            # Add creator if specified
            creator = metadata_dict.get('Creator', '')
            if creator:
                cmd.insert(-1, '-metadata')
                cmd.insert(-1, f'author={creator}')
            
            # Run ffmpeg
            process = subprocess.run(cmd, capture_output=True, text=True)
            
            if process.returncode == 0:
                # Replace original with temp file
                os.remove(video_path)
                os.rename(temp_path, video_path)
                self.log(f"Video metadata added successfully", "success")
                return True
            else:
                self.log(f"FFmpeg error: {process.stderr[:200]}", "error")
                if os.path.exists(temp_path):
                    os.remove(temp_path)
                return False
                
        except Exception as e:
            self.log(f"Error adding generic metadata: {e}", "error")
            if os.path.exists(temp_path):
                os.remove(temp_path)
            return False
    
    def process_video(self, input_path, output_path, metadata_dict):
        """Process a single video file"""
        try:
            self.log(f"Processing video: {os.path.basename(input_path)}")
            
            # Check ffmpeg
            if not self.check_ffmpeg():
                return False
            
            # Step 1: Copy video and strip all metadata
            if not self.strip_video_metadata(input_path, output_path):
                self.log(f"Failed to strip metadata, trying direct copy...", "warning")
                # Fallback: simple copy
                shutil.copy2(input_path, output_path)
            
            # Step 2: Add custom metadata
            if not self.add_video_metadata(output_path, metadata_dict):
                self.log(f"Failed to add custom metadata", "warning")
                # Continue anyway, at least metadata was stripped
            
            self.log(f"Saved: {os.path.basename(output_path)}", "success")
            return True
            
        except Exception as e:
            self.log(f"Error processing video: {e}", "error")
            return False

# ============================================================================
# METADATA ENGINE - AUDIO
# ============================================================================

class AudioMetadataEngine:
    """Audio metadata processing engine"""
    
    def __init__(self, verbose=False):
        self.verbose = verbose
    
    def log(self, message, level="info"):
        """Log messages"""
        if self.verbose or level in ["success", "error", "warning"]:
            prefixes = {
                "info": "[*]",
                "success": "[âœ…]",
                "warning": "[âš ï¸]",
                "error": "[âŒ]"
            }
            print(f"{prefixes.get(level, '[ ]')} {message}")
    
    def strip_audio_metadata(self, audio_path):
        """Strip all metadata from audio file"""
        try:
            self.log(f"Stripping metadata from audio...")
            
            # Create a clean copy without metadata using mutagen
            audio = mutagen.File(audio_path, easy=True)
            if audio is None:
                self.log(f"Unsupported audio format or corrupt file", "warning")
                return None
            
            # Get audio data
            audio_data = mutagen.File(audio_path)
            
            # For MP3 files
            if audio_path.lower().endswith('.mp3'):
                # Remove all ID3 tags
                try:
                    audio = ID3(audio_path)
                    audio.delete()
                    audio.save()
                except:
                    pass
            
            # For other formats, mutagen will handle
            audio.delete()
            
            self.log(f"Audio metadata stripped", "success")
            return audio_data
            
        except Exception as e:
            self.log(f"Error stripping audio metadata: {e}", "error")
            return None
    
    def add_audio_metadata(self, audio_path, metadata_dict):
        """Add custom metadata to audio file"""
        try:
            self.log(f"Adding metadata to audio...")
            
            audio_ext = Path(audio_path).suffix.lower()
            
            if audio_ext == '.mp3':
                return self.add_mp3_metadata(audio_path, metadata_dict)
            elif audio_ext in ['.m4a', '.mp4']:
                return self.add_m4a_metadata(audio_path, metadata_dict)
            elif audio_ext in ['.flac', '.wav', '.ogg', '.aac']:
                return self.add_generic_audio_metadata(audio_path, metadata_dict)
            else:
                self.log(f"Unsupported audio format: {audio_ext}", "warning")
                return False
                
        except Exception as e:
            self.log(f"Error adding audio metadata: {e}", "error")
            return False
    
    def add_mp3_metadata(self, audio_path, metadata_dict):
        """Add metadata to MP3 files"""
        try:
            # Create or load ID3 tags
            try:
                audio = ID3(audio_path)
            except:
                audio = ID3()
            
            # Clear existing tags
            audio.delete()
            
            # Add new tags
            device = metadata_dict.get('Device', 'iPhone Voice Memo')
            date_str = metadata_dict.get('Date', datetime.now().strftime('%m.%d.%Y'))
            time_str = metadata_dict.get('Time', datetime.now().strftime('%H:%M:%S'))
            
            # Title
            audio.add(TIT2(encoding=3, text="Voice Recording"))
            
            # Artist/Device
            artist = metadata_dict.get('Artist', device)
            audio.add(TPE1(encoding=3, text=artist))
            
            # Album
            album = metadata_dict.get('Album', 'Recordings')
            audio.add(TALB(encoding=3, text=album))
            
            # Year/Date
            try:
                date_obj = datetime.strptime(date_str, '%m.%d.%Y')
                year = date_obj.year
                audio.add(TDRC(encoding=3, text=str(year)))
            except:
                pass
            
            # Comment
            comment = f"Recorded on {device} at {time_str}"
            location = metadata_dict.get('Location', '')
            if location:
                comment += f" in {location}"
            audio.add(COMM(encoding=3, lang='eng', desc='', text=comment))
            
            # Custom field with all metadata
            custom_data = json.dumps({
                'ProcessedBy': Config.APP_NAME,
                'Device': device,
                'Date': date_str,
                'Time': time_str
            })
            audio.add(TXXX(encoding=3, desc='CustomMetadata', text=custom_data))
            
            # Save
            audio.save(audio_path, v2_version=3)
            
            self.log(f"MP3 metadata added successfully", "success")
            return True
            
        except Exception as e:
            self.log(f"Error adding MP3 metadata: {e}", "error")
            return False
    
    def add_m4a_metadata(self, audio_path, metadata_dict):
        """Add metadata to M4A/MP4 audio files"""
        try:
            audio = MP4(audio_path)
            
            # Clear existing metadata
            audio.clear()
            
            # Add metadata
            device = metadata_dict.get('Device', 'iPhone Voice Memo')
            date_str = metadata_dict.get('Date', datetime.now().strftime('%m.%d.%Y'))
            time_str = metadata_dict.get('Time', datetime.now().strftime('%H:%M:%S'))
            
            audio["\xa9nam"] = ["Voice Recording"]
            audio["\xa9ART"] = [metadata_dict.get('Artist', device)]
            audio["\xa9alb"] = [metadata_dict.get('Album', 'Recordings')]
            
            # Convert date
            try:
                date_obj = datetime.strptime(date_str, '%m.%d.%Y')
                iso_date = date_obj.strftime('%Y-%m-%d')
                audio["\xa9day"] = [iso_date]
            except:
                pass
            
            audio["\xa9cmt"] = [f"Recorded on {device} at {time_str}"]
            
            # Save
            audio.save()
            
            self.log(f"M4A metadata added successfully", "success")
            return True
            
        except Exception as e:
            self.log(f"Error adding M4A metadata: {e}", "error")
            return False
    
    def add_generic_audio_metadata(self, audio_path, metadata_dict):
        """Add metadata to generic audio formats"""
        try:
            audio = mutagen.File(audio_path, easy=True)
            if audio is None:
                return False
            
            # Clear and add new metadata
            audio.delete()
            
            device = metadata_dict.get('Device', 'Unknown Device')
            date_str = metadata_dict.get('Date', datetime.now().strftime('%m.%d.%Y'))
            time_str = metadata_dict.get('Time', datetime.now().strftime('%H:%M:%S'))
            
            audio['title'] = "Voice Recording"
            audio['artist'] = metadata_dict.get('Artist', device)
            audio['album'] = metadata_dict.get('Album', 'Recordings')
            
            try:
                date_obj = datetime.strptime(date_str, '%m.%d.%Y')
                audio['date'] = str(date_obj.year)
            except:
                pass
            
            audio['comment'] = f"Recorded on {device} at {time_str}"
            
            audio.save()
            
            self.log(f"Audio metadata added successfully", "success")
            return True
            
        except Exception as e:
            self.log(f"Error adding audio metadata: {e}", "error")
            return False
    
    def process_audio(self, input_path, output_path, metadata_dict):
        """Process a single audio file"""
        try:
            self.log(f"Processing audio: {os.path.basename(input_path)}")
            
            # For audio, we can just copy and modify
            shutil.copy2(input_path, output_path)
            
            # Add custom metadata
            if not self.add_audio_metadata(output_path, metadata_dict):
                self.log(f"Failed to add custom metadata", "warning")
                # Still successful since we stripped metadata
            
            self.log(f"Saved: {os.path.basename(output_path)}", "success")
            return True
            
        except Exception as e:
            self.log(f"Error processing audio: {e}", "error")
            return False

# ============================================================================
# MAIN PROCESSING CONTROLLER
# ============================================================================

class MediaProcessor:
    """Main media processing controller"""
    
    def __init__(self, verbose=False):
        self.verbose = verbose
        self.image_engine = ImageMetadataEngine(verbose)
        self.video_engine = VideoMetadataEngine(verbose)
        self.audio_engine = AudioMetadataEngine(verbose)
        
        self.stats = {
            'total': 0,
            'images': 0,
            'videos': 0,
            'audio': 0,
            'success': 0,
            'failed': 0,
            'ai_detected': 0
        }
    
    def process_media(self, input_path, output_path, metadata_dict, media_type=None):
        """Process media file based on type"""
        # Determine media type if not specified
        if not media_type:
            ext = Path(input_path).suffix.lower()
            if ext in Config.SUPPORTED_IMAGE_FORMATS:
                media_type = "image"
            elif ext in Config.SUPPORTED_VIDEO_FORMATS:
                media_type = "video"
            elif ext in Config.SUPPORTED_AUDIO_FORMATS:
                media_type = "audio"
            else:
                print(f"âŒ Unsupported file type: {ext}")
                return False
        
        self.stats['total'] += 1
        
        # Route to appropriate processor
        if media_type == "image":
            self.stats['images'] += 1
            success = self.image_engine.process_image(input_path, output_path, metadata_dict)
        elif media_type == "video":
            self.stats['videos'] += 1
            success = self.video_engine.process_video(input_path, output_path, metadata_dict)
        elif media_type == "audio":
            self.stats['audio'] += 1
            success = self.audio_engine.process_audio(input_path, output_path, metadata_dict)
        else:
            success = False
        
        if success:
            self.stats['success'] += 1
        else:
            self.stats['failed'] += 1
        
        return success
    
    def process_batch(self, input_dir, output_dir, metadata_dict):
        """Process all media in a directory"""
        print(f"\n{'='*60}")
        print("  PROCESSING MEDIA FILES")
        print(f"{'='*60}")
        
        # Find all media files
        media_files = []
        for ext in Config.ALL_SUPPORTED_FORMATS:
            for pattern in [f"*{ext}", f"*{ext.upper()}"]:
                media_files.extend(Path(input_dir).rglob(pattern))
        
        if not media_files:
            print("âš ï¸  No media files found to process")
            return
        
        print(f"ğŸ“Š Found {len(media_files)} media file(s) to process")
        
        # Process each file
        for media_file in media_files:
            rel_path = media_file.relative_to(input_dir)
            out_file = Path(output_dir) / rel_path
            
            # Create output directory if needed
            out_file.parent.mkdir(parents=True, exist_ok=True)
            
            # Determine media type
            ext = media_file.suffix.lower()
            if ext in Config.SUPPORTED_IMAGE_FORMATS:
                media_type = "image"
                icon = "ğŸ“¸"
            elif ext in Config.SUPPORTED_VIDEO_FORMATS:
                media_type = "video"
                icon = "ğŸ¥"
            elif ext in Config.SUPPORTED_AUDIO_FORMATS:
                media_type = "audio"
                icon = "ğŸµ"
            else:
                continue
            
            print(f"\n{icon} Processing: {media_file.name}")
            self.process_media(str(media_file), str(out_file), metadata_dict, media_type)
        
        # Print summary
        self.print_summary()
    
    def print_summary(self):
        """Print processing summary"""
        print(f"\n{'='*60}")
        print("  PROCESSING SUMMARY")
        print(f"{'='*60}")
        print(f"ğŸ“Š Total files processed: {self.stats['total']}")
        print(f"   ğŸ“¸ Images: {self.stats['images']}")
        print(f"   ğŸ¥ Videos: {self.stats['videos']}")
        print(f"   ğŸµ Audio: {self.stats['audio']}")
        print(f"\nâœ… Successful: {self.stats['success']}")
        print(f"âŒ Failed: {self.stats['failed']}")
        print(f"ğŸ¤– AI metadata detected: {self.stats.get('ai_detected', 0)}")
        print(f"{'='*60}")

# ============================================================================
# MAIN APPLICATION
# ============================================================================

class MetadataScrubberApp:
    """Main application controller"""
    
    def __init__(self):
        self.config_file = Path(Config.CONFIG_FILE)
        self.first_run = not self.config_file.exists()
        self.processor = None
    
    def print_welcome(self):
        """Print welcome message with custom banner"""
        # Clear screen
        os.system('clear' if os.name == 'posix' else 'cls')
        
        # Print custom banner
        print("\033[1;36m")  # Cyan color
        print(CUSTOM_BANNER)
        print("\033[0m")  # Reset color
        
        # Print credits
        print("\033[1;33m")  # Yellow color
        print(CREDITS)
        print("\033[0m")  # Reset color
        
        print("\033[1;32m" + "â•" * 60 + "\033[0m")
        print(f"\033[1;35m  Complete Media Metadata Scrubber - Images, Videos & Audio\033[0m")
        print(f"\033[1;35m  Version: {Config.VERSION}\033[0m")
        print("\033[1;32m" + "â•" * 60 + "\033[0m")
        
        if self.first_run:
            print("\n\033[1;33mğŸ‘‹ Welcome! This appears to be your first run.\033[0m")
            print("\033[1;33m   I'll help you set up everything.\033[0m")
    
    def save_config(self, metadata_dict):
        """Save configuration for future runs"""
        config_data = {
            'first_run': False,
            'last_metadata': metadata_dict,
            'last_run': datetime.now().isoformat(),
            'version': Config.VERSION
        }
        
        with open(self.config_file, 'w') as f:
            json.dump(config_data, f, indent=2)
    
    def load_config(self):
        """Load previous configuration"""
        if self.config_file.exists():
            try:
                with open(self.config_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return None
    
    def get_metadata_for_type(self, media_type):
        """Get metadata configuration for specific media type"""
        # Try to load previous config
        prev_config = self.load_config()
        
        if prev_config and 'last_metadata' in prev_config:
            print(f"\nğŸ“‹ Previous {media_type} configuration found.")
            reuse = input(f"Reuse previous {media_type} configuration? (yes/no) [yes]: ").strip().lower()
            if reuse in ['', 'yes', 'y', '1']:
                return prev_config['last_metadata']
        
        # Get new configuration
        return MetadataWizard.get_metadata_interactive(media_type)
    
    def run(self):
        """Main application flow"""
        self.print_welcome()
        
        # Step 1: Setup folders
        print("\n\033[1;36m" + "â•" * 60 + "\033[0m")
        print("\033[1;36m  INITIALIZING APPLICATION\033[0m")
        print("\033[1;36m" + "â•" * 60 + "\033[0m")
        
        input_dir, output_dir = FolderManager.setup_folders()
        
        # Step 2: Check for media
        FolderManager.show_folder_contents()
        
        # Step 3: Check what types of media we have
        print("\n\033[1;36m" + "â•" * 60 + "\033[0m")
        print("\033[1;36m  MEDIA TYPE DETECTION\033[0m")
        print("\033[1;36m" + "â•" * 60 + "\033[0m")
        
        media_types = set()
        for ext in Config.ALL_SUPPORTED_FORMATS:
            for file in Path(input_dir).glob(f"*{ext}"):
                if ext in Config.SUPPORTED_IMAGE_FORMATS:
                    media_types.add("image")
                elif ext in Config.SUPPORTED_VIDEO_FORMATS:
                    media_types.add("video")
                elif ext in Config.SUPPORTED_AUDIO_FORMATS:
                    media_types.add("audio")
        
        if not media_types:
            print("âš ï¸  No media files found in input folder.")
            print(f"   Please add files to {input_dir}/ and run again.")
            return
        
        print(f"ğŸ“Š Detected media types: {', '.join(sorted(media_types))}")
        
        # Step 4: Get metadata configuration for each type
        print("\n\033[1;36m" + "â•" * 60 + "\033[0m")
        print("\033[1;36m  METADATA CONFIGURATION\033[0m")
        print("\033[1;36m" + "â•" * 60 + "\033[0m")
        
        metadata_configs = {}
        
        # For mixed media, we need separate configs or unified config
        if len(media_types) == 1:
            # Single media type
            media_type = list(media_types)[0]
            metadata = self.get_metadata_for_type(media_type)
            if not metadata:
                print("Configuration cancelled.")
                return
            metadata_configs[media_type] = metadata
        else:
            # Multiple media types
            print("\nğŸ“‹ You have multiple media types. Configure each separately:")
            
            for media_type in sorted(media_types):
                print(f"\n\033[1;33m--- {media_type.upper()} CONFIGURATION ---\033[0m")
                metadata = self.get_metadata_for_type(media_type)
                if not metadata:
                    print(f"{media_type} configuration cancelled.")
                    continue
                metadata_configs[media_type] = metadata
        
        if not metadata_configs:
            print("No valid configurations provided. Operation cancelled.")
            return
        
        # Step 5: Initialize processor
        self.processor = MediaProcessor(verbose=True)
        
        # Step 6: Confirm and process
        print("\n\033[1;36m" + "â•" * 60 + "\033[0m")
        print("\033[1;36m  READY TO PROCESS\033[0m")
        print("\033[1;36m" + "â•" * 60 + "\033[0m")
        
        print("\nğŸ“‹ Configuration Summary:")
        for media_type, metadata in metadata_configs.items():
            print(f"\n\033[1;33m{media_type.upper()}:\033[0m")
            for key, value in metadata.items():
                if key not in ['AddGPS', 'AddCameraSettings']:
                    print(f"  {key}: {value}")
        
        print(f"\nğŸ“ Input folder: {input_dir}/")
        print(f"ğŸ“ Output folder: {output_dir}/")
        
        confirm = input("\nStart processing? (yes/no) [yes]: ").strip().lower()
        if confirm not in ['', 'yes', 'y', '1']:
            print("Processing cancelled.")
            return
        
        # Step 7: Process media
        print("\n\033[1;36m" + "â•" * 60 + "\033[0m")
        print("\033[1;36m  PROCESSING MEDIA\033[0m")
        print("\033[1;36m" + "â•" * 60 + "\033[0m")
        
        # Process each file with appropriate configuration
        for media_type, metadata in metadata_configs.items():
            # Filter files by type
            if media_type == "image":
                extensions = Config.SUPPORTED_IMAGE_FORMATS
            elif media_type == "video":
                extensions = Config.SUPPORTED_VIDEO_FORMATS
            elif media_type == "audio":
                extensions = Config.SUPPORTED_AUDIO_FORMATS
            else:
                continue
            
            # Find files of this type
            files_to_process = []
            for ext in extensions:
                files_to_process.extend(Path(input_dir).glob(f"*{ext}"))
                files_to_process.extend(Path(input_dir).glob(f"*{ext.upper()}"))
            
            if files_to_process:
                print(f"\nğŸ”„ Processing {len(files_to_process)} {media_type}(s)...")
                
                for file in files_to_process:
                    rel_path = file.relative_to(input_dir)
                    out_file = Path(output_dir) / rel_path
                    out_file.parent.mkdir(parents=True, exist_ok=True)
                    
                    self.processor.process_media(str(file), str(out_file), metadata, media_type)
        
        # Step 8: Save configuration
        if metadata_configs:
            # Save the first configuration (or create combined one)
            first_type = list(metadata_configs.keys())[0]
            self.save_config(metadata_configs[first_type])
        
        # Step 9: Show completion
        print("\n\033[1;32m" + "â•" * 60 + "\033[0m")
        print("\033[1;32m  PROCESSING COMPLETE!\033[0m")
        print("\033[1;32m" + "â•" * 60 + "\033[0m")
        print(f"\nâœ… All media has been processed.")
        print(f"ğŸ“ Check the results in: {output_dir}/")
        print(f"\nğŸ” To verify metadata:")
        print(f"   Images: exiftool {output_dir}/*.jpg")
        print(f"   Videos: ffprobe -v quiet -show_format {output_dir}/*.mp4")
        print(f"   Audio:  mediainfo {output_dir}/*.mp3")
        print("\n\033[1;33m" + "â•" * 60 + "\033[0m")
        print("\033[1;33m  Thank you for using META DATA SCRUBBER!\033[0m")
        print("\033[1;33m  Developer: Professor | Contact: +880 1708005924 (WhatsApp)\033[0m")
        print("\033[1;33m" + "â•" * 60 + "\033[0m")

# ============================================================================
# COMMAND LINE INTERFACE
# ============================================================================

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description=f'{Config.APP_NAME} - Remove AI metadata and add custom metadata to images, videos & audio',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=f"""
Quick Start:
  1. Run without arguments for interactive mode
  2. Place media in 'input_media/' folder
  3. Follow the step-by-step wizard
  4. Get results in 'scrubbed_media/' folder

Developer: Professor
Contact: +880 1708005924 (WhatsApp)

Examples:
  %(prog)s                    # Interactive wizard mode
  %(prog)s --quick            # Quick mode with defaults
  %(prog)s --verbose          # Show detailed processing info
  %(prog)s --reset            # Reset configuration

Requirements:
  â€¢ Python: Pillow, piexif, mutagen
  â€¢ FFmpeg: sudo apt install ffmpeg  or  brew install ffmpeg
        """
    )
    
    parser.add_argument('--quick', '-q', action='store_true',
                       help='Quick mode with default settings')
    parser.add_argument('--verbose', '-v', action='store_true',
                       help='Verbose output')
    parser.add_argument('--reset', '-r', action='store_true',
                       help='Reset configuration and folders')
    
    args = parser.parse_args()
    
    # Handle reset
    if args.reset:
        confirm = input("Reset all configuration and folders? This cannot be undone. (yes/no): ")
        if confirm.lower() in ['yes', 'y']:
            if os.path.exists(Config.CONFIG_FILE):
                os.remove(Config.CONFIG_FILE)
            if os.path.exists(Config.DEFAULT_INPUT_DIR):
                shutil.rmtree(Config.DEFAULT_INPUT_DIR)
            if os.path.exists(Config.DEFAULT_OUTPUT_DIR):
                shutil.rmtree(Config.DEFAULT_OUTPUT_DIR)
            print("âœ… Configuration and folders reset.")
        return
    
    # Check dependencies
    print("ğŸ” Checking dependencies...")
    try:
        import PIL
        import piexif
        import mutagen
        print("âœ… Python dependencies OK")
    except ImportError as e:
        print(f"âŒ Missing dependency: {e}")
        print("Install with: pip install Pillow piexif mutagen")
        return
    
    # Check ffmpeg
    try:
        result = subprocess.run([Config.FFMPEG_PATH, "-version"], 
                              capture_output=True, text=True, timeout=5)
        if result.returncode == 0:
            print("âœ… FFmpeg OK")
        else:
            print("âš ï¸  FFmpeg found but may have issues")
    except:
        print("âš ï¸  FFmpeg not found (video processing will be limited)")
        print("Install with: sudo apt install ffmpeg  or  brew install ffmpeg")
    
    # Run application
    try:
        app = MetadataScrubberApp()
        app.run()
    except KeyboardInterrupt:
        print("\n\nâš ï¸  Operation cancelled by user.")
        sys.exit(1)
    except Exception as e:
        print(f"\nâŒ Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()
